name: Production v31 (Full Data Fix)

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */6 * * *'

jobs:
  run-stack:
    runs-on: ubuntu-latest
    timeout-minutes: 355
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      # 1. START NGROK
      - name: üöá Start Ngrok
        run: |
          curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
          echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
          sudo apt update && sudo apt install ngrok
          ngrok config add-authtoken ${{ secrets.NGROK_TOKEN }}
          ngrok http --domain=${{ secrets.NGROK_DOMAIN }} 80 > ngrok.log &
          sleep 5

      # 2. SETUP SYNC ENGINE
      - name: üîÆ Setup Engine
        run: |
          npm install @supabase/supabase-js
          mkdir -p n8n_data && chmod 777 n8n_data
          cat << 'EOF' > sync.js
          const { createClient } = require('@supabase/supabase-js');
          const fs = require('fs');
          const path = 'n8n_data/database.sqlite';
          const supabaseUrl = 'https://ymatdzammnejrmmiyygg.supabase.co';
          const supabase = createClient(supabaseUrl, process.env.SUPABASE_KEY);
          async function run(mode) {
            if(mode==='down') {
              const { data, error } = await supabase.storage.from('bot-storage').download('database.sqlite');
              if(!error) fs.writeFileSync(path, Buffer.from(await data.arrayBuffer()));
            } else {
              if(fs.existsSync(path)) await supabase.storage.from('bot-storage').upload('database.sqlite', fs.readFileSync(path), { upsert: true });
            }
          }
          run(process.argv[2]);
          EOF

      # 3. RESTORE DB
      - name: üì• Restore DB
        continue-on-error: true
        env:
          SUPABASE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE }}
        run: node sync.js down

      # 4. CREATE BOT (With FULL DATA LOGIC)
      - name: üìù Create Bot
        run: |
          mkdir whatsapp
          echo '{"name":"wa-bot","dependencies":{"@whiskeysockets/baileys":"6.6.0","axios":"^1.6.0","express":"^4.18.2","mongoose":"^8.0.0","pino":"^8.16.1","qrcode":"^1.5.3","node-cache":"^5.1.2"}}' > whatsapp/package.json

          cat << 'EOF' > whatsapp/index.js
          const { default: makeWASocket, DisconnectReason, BufferJSON, useMultiFileAuthState, makeCacheableSignalKeyStore } = require('@whiskeysockets/baileys');
          const express = require('express'); const axios = require('axios'); const mongoose = require('mongoose'); const QRCode = require('qrcode'); const pino = require('pino'); const NodeCache = require('node-cache');
          
          const app = express(); app.use(express.json());
          
          const PORT = 10000;
          const N8N_URL = "http://n8n:5678/webhook/whatsapp"; 
          const MONGO_URL = process.env.MONGODB_URI;
          const COLLECTION_NAME = 'Auth_Final_v1'; 

          const authSchema = new mongoose.Schema({ _id: String, data: Object });
          const AuthModel = mongoose.model(COLLECTION_NAME, authSchema);

          async function useMongoDB() {
              const writeData = async (data, id) => {
                  try {
                      const json = JSON.parse(JSON.stringify(data, BufferJSON.replacer));
                      await AuthModel.findOneAndUpdate({ _id: id }, { data: json, _id: id }, { upsert: true });
                  } catch (err) {}
              };
              const readData = async (id) => {
                  try {
                      const doc = await AuthModel.findById(id);
                      return doc ? JSON.parse(JSON.stringify(doc.data), BufferJSON.reviver) : null;
                  } catch (err) { return null; }
              };
              const removeData = async (id) => { try { await AuthModel.findByIdAndDelete(id); } catch (err) {} };
              const creds = (await readData('creds')) || (await (require('@whiskeysockets/baileys').initAuthCreds)());
              return {
                  state: {
                      creds,
                      keys: {
                          get: async (type, ids) => {
                              const data = {};
                              await Promise.all(ids.map(async (id) => {
                                  let val = await readData(`${type}-${id}`);
                                  if (type === 'app-state-sync-key' && val) val = require('@whiskeysockets/baileys/lib/Utils/auth-utils').proto.Message.AppStateSyncKeyData.fromObject(val);
                                  if (val) data[id] = val;
                              }));
                              return data;
                          },
                          set: async (data) => {
                              const tasks = [];
                              for (const cat in data) for (const id in data[cat]) { const val = data[cat][id]; const key = `${cat}-${id}`; tasks.push(val ? writeData(val, key) : removeData(key)); }
                              await Promise.all(tasks);
                          }
                      }
                  },
                  saveCreds: () => writeData(creds, 'creds'),
                  clear: async () => { await AuthModel.deleteMany({}); }
              };
          }

          let sock; let qrData = null;
          async function start() {
              try {
                  if(mongoose.connection.readyState === 0) await mongoose.connect(MONGO_URL);
                  const { state, saveCreds, clear } = await useMongoDB();
                  global.clear = clear;

                  sock = makeWASocket({
                      auth: { creds: state.creds, keys: makeCacheableSignalKeyStore(state.keys, pino({ level: "fatal" })) },
                      logger: pino({ level: 'silent' }),
                      printQRInTerminal: false,
                      browser: ["Shiksha Bot", "Chrome", "1.0.0"],
                      connectTimeoutMs: 60000,
                  });

                  sock.ev.on('creds.update', saveCreds);
                  sock.ev.on('connection.update', async (update) => {
                      const { connection, lastDisconnect, qr } = update;
                      if(qr) { qrData = qr; console.log("QR Generated"); }
                      if(connection === 'open') { qrData = null; console.log("Connected"); }
                      if(connection === 'close') {
                          const code = lastDisconnect.error?.output?.statusCode;
                          if(code === DisconnectReason.loggedOut) { await clear(); process.exit(1); } 
                          else { setTimeout(start, 3000); }
                      }
                  });
                  
                  // üî• FIXED: Sending Full JSON Data üî•
                  sock.ev.on('messages.upsert', async ({ messages }) => {
                      const msg = messages[0]; if(!msg.message || msg.key.fromMe) return;
                      try {
                          const realNumber = (msg.key.participant || msg.key.remoteJid).split('@')[0];
                          await axios.post(N8N_URL, { 
                              from: realNumber, 
                              text: msg.message.conversation || msg.message.extendedTextMessage?.text, 
                              name: msg.pushName,
                              full_json: msg // <--- Added This Line
                          });
                      } catch (e) {}
                  });

              } catch (e) { setTimeout(start, 5000); }
          }

          app.post('/send', async (req, res) => {
              try {
                  if (!sock) return res.status(503).json({ error: "Bot starting..." });
                  const { number, message } = req.body;
                  const fullId = number.includes('@') ? number : `${number}@s.whatsapp.net`;
                  await sock.sendMessage(fullId, { text: message });
                  res.json({ status: true });
              } catch (e) { res.status(500).json({ error: e.message }); }
          });

          app.get('/qr', async (req, res) => {
              if(sock?.user && !qrData) return res.send('<h1>‚úÖ Connected!</h1><a href="/reset">Reset</a>');
              if(!qrData) return res.send('<h1>‚è≥ Generating QR... Refresh in 5s</h1>');
              const url = await QRCode.toDataURL(qrData);
              res.send(`<div style="text-align:center"><h1>Scan This (v31)</h1><img src="${url}" /><br/><a href="/reset">Reset Database</a></div>`);
          });

          app.get('/reset', async (req, res) => {
              if(global.clear) await global.clear();
              res.send("<h1>Database Wiped. Restarting...</h1>");
              process.exit(1);
          });

          app.listen(PORT, () => { console.log(`Server on ${PORT}`); start(); });
          EOF

      # 5. START SERVICES
      - name: üöÄ Start Everything
        run: |
          docker network create bot-net

          cat << 'EOF' > Caddyfile
          :80 {
            reverse_proxy /qr wa-bot:10000
            reverse_proxy /reset wa-bot:10000
            reverse_proxy /send wa-bot:10000
            reverse_proxy /* n8n:5678
          }
          EOF
          docker run -d --name caddy --network bot-net -p 80:80 -v $(pwd)/Caddyfile:/etc/caddy/Caddyfile caddy

          docker run -d --name n8n --network bot-net \
            -v $(pwd)/n8n_data:/home/node/.n8n \
            -e N8N_ENCRYPTION_KEY="kuchbhi123" \
            -e N8N_SECURE_COOKIE=false \
            -e WEBHOOK_URL="https://${{ secrets.NGROK_DOMAIN }}" \
            n8nio/n8n

          docker run -d --name wa-bot --network bot-net \
            -v $(pwd)/whatsapp:/app -w /app \
            -e MONGODB_URI="${{ secrets.MONGODB_URI }}" \
            node:20-alpine sh -c "apk add --no-cache git && npm install && while true; do node index.js; echo 'Restarting...'; sleep 2; done"

      # 6. SYNC LOOP
      - name: üíæ Sync Loop
        env:
          SUPABASE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE }}
        run: |
          for i in {1..20}; do sleep 900; node sync.js up; done
          sleep 600
