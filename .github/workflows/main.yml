name: Step 2 - Real Bot (QR Test)

on: workflow_dispatch

jobs:
  real-bot-setup:
    runs-on: ubuntu-latest
    timeout-minutes: 350
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      # 1. Start Ngrok (Tunneling Port 10000)
      - name: üöá Start Ngrok
        run: |
          curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc >/dev/null
          echo "deb https://ngrok-agent.s3.amazonaws.com buster main" | sudo tee /etc/apt/sources.list.d/ngrok.list
          sudo apt update && sudo apt install ngrok
          ngrok config add-authtoken ${{ secrets.NGROK_TOKEN }}
          ngrok http --domain=${{ secrets.NGROK_DOMAIN }} 10000 > ngrok.log &
          sleep 5

      # 2. Update Netlify (To Point to Ngrok)
      - name: üåê Update Netlify
        run: |
          npm install -g netlify-cli
          rm -rf public && mkdir public
          echo '<h1>Bot Initializing...</h1>' > public/index.html
          echo "/* https://${{ secrets.NGROK_DOMAIN }}/:splat 200!" > public/_redirects
          netlify deploy --prod --site ${{ secrets.NETLIFY_SITE_ID }} --auth ${{ secrets.NETLIFY_TOKEN }} --dir=public

      # 3. Install & Start Real WhatsApp Bot (Directly on Runner)
      - name: ü§ñ Run Real Bot
        env:
          MONGODB_URI: ${{ secrets.MONGODB_URI }}
        run: |
          mkdir whatsapp
          cd whatsapp
          
          # Initialize & Install Real Libraries
          npm init -y
          npm install @whiskeysockets/baileys axios express mongoose qrcode pino node-cache
          
          # Create The Bot File
          cat << 'EOF' > index.js
          const { default: makeWASocket, useMultiFileAuthState, makeCacheableSignalKeyStore, DisconnectReason, BufferJSON } = require('@whiskeysockets/baileys');
          const express = require('express');
          const mongoose = require('mongoose');
          const QRCode = require('qrcode');
          const pino = require('pino');
          const NodeCache = require('node-cache');
          
          const app = express();
          const MONGO_URL = process.env.MONGODB_URI;
          
          // --- MONGODB CONNECTION ---
          if (!MONGO_URL) { console.error("‚ùå MONGODB_URI Missing!"); process.exit(1); }
          const authSchema = new mongoose.Schema({ _id: String, data: Object });
          const AuthModel = mongoose.model('Auth', authSchema);
          
          async function useMongoDB() {
              const writeData = async (data, id) => { try { await AuthModel.findOneAndUpdate({ _id: id }, { data: JSON.parse(JSON.stringify(data, BufferJSON.replacer)), _id: id }, { upsert: true }); } catch (err) {} };
              const readData = async (id) => { try { const doc = await AuthModel.findById(id); return doc ? JSON.parse(JSON.stringify(doc.data), BufferJSON.reviver) : null; } catch (err) { return null; } };
              const removeData = async (id) => { try { await AuthModel.findByIdAndDelete(id); } catch (err) {} };
              const creds = (await readData('creds')) || (await (require('@whiskeysockets/baileys').initAuthCreds)());
              return { state: { creds, keys: { get: async (type, ids) => { const data = {}; await Promise.all(ids.map(async (id) => { let val = await readData(`${type}-${id}`); if (type === 'app-state-sync-key' && val) val = require('@whiskeysockets/baileys/lib/Utils/auth-utils').proto.Message.AppStateSyncKeyData.fromObject(val); if (val) data[id] = val; })); return data; }, set: async (data) => { const tasks = []; for (const cat in data) for (const id in data[cat]) { const val = data[cat][id]; const key = `${cat}-${id}`; tasks.push(val ? writeData(val, key) : removeData(key)); } await Promise.all(tasks); } } }, saveCreds: () => writeData(creds, 'creds'), clear: async () => { await AuthModel.deleteMany({}); } };
          }

          let sock;
          let qrData = null;
          
          async function startBot() {
              await mongoose.connect(MONGO_URL);
              console.log("‚úÖ DB Connected");
              
              const { state, saveCreds } = await useMongoDB();
              
              sock = makeWASocket({
                  auth: { creds: state.creds, keys: makeCacheableSignalKeyStore(state.keys, pino({ level: "fatal" })) },
                  printQRInTerminal: true,
                  logger: pino({ level: 'silent' }),
                  browser: ["GitHub Bot", "Chrome", "20.0.0"]
              });
              
              sock.ev.on('creds.update', saveCreds);
              sock.ev.on('connection.update', (update) => {
                  const { connection, lastDisconnect, qr } = update;
                  if(qr) qrData = qr;
                  if(connection === 'open') { qrData = null; console.log("‚úÖ WhatsApp Connected!"); }
                  if(connection === 'close') {
                      const shouldReconnect = lastDisconnect.error?.output?.statusCode !== DisconnectReason.loggedOut;
                      if(shouldReconnect) startBot();
                  }
              });
          }
          
          app.get('/qr', async (req, res) => {
             if (sock?.ws?.isOpen) return res.send('<h1 style="color:green">‚úÖ Connected! Bot is Ready.</h1>');
             if (!qrData) return res.send('<h1>Starting... Please refresh in 5 seconds.</h1>');
             const url = await QRCode.toDataURL(qrData);
             res.send(`<div style="text-align:center"><h1>Scan This QR</h1><img src="${url}" width="300"/></div>`);
          });
          
          app.get('/', (req, res) => res.send('Bot Server Running'));
          
          app.listen(10000, () => {
              console.log("Server on 10000");
              startBot();
          });
          EOF
          
          # Start Node
          node index.js
